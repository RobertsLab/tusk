[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Where the fun starts",
    "section": "",
    "text": "This is a portal developed out as a Course Set where core learning modules exist. Please see sidebar menu for specific modules. There is a logic to the order as modules build as you go down the list, though they are developed where they are also stand-alone.\nIf you want to contribute, have suggestions, want to see additional resources related to data science, or learn more about what our lab does please visit the about page."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is a Quarto Website that you can contribute to at\nhttps://github.com/RobertsLab/tusk\nPlease see the readme file for instructions and guidelines for contribution."
  },
  {
    "objectID": "modules/00-markdown.html",
    "href": "modules/00-markdown.html",
    "title": "markdown",
    "section": "",
    "text": "Markdown is a lightweight markup language created by John Gruber and Aaron Swartz in 2004. It is designed to be easy-to-read and easy-to-write. The syntax allows you to format text using simple symbols and characters you already know. For example, you can use asterisks * or underscores _ to create italics or bold text. You can also create lists, headers, links, and many other formatting features easily.\n\n\n\n\nMarkdown is much simpler to learn compared to other markup languages like HTML. This makes it a quick tool for anyone who wants to write well-formatted content without the steep learning curve.\n\n\n\nMarkdown files are plain text files with a .md extension, which means they can be opened with any text editor. This makes them extremely portable and easy to manage.\n\n\n\nMarkdown is commonly used for readme files, GitHub repositories, blogging platforms like Jekyll, and even in data science notebooks like Jupyter.\n\n\n\nThe syntax is designed to be readable as-is, so even if you’re not rendering the Markdown to HTML or another format, it’s still easy to understand what’s going on.\n\n\n\n\nHere are some basic examples of Markdown syntax:\n\nHeaders:\n# H1\n## H2\n### H3\nLists:\n- Item 1\n- Item 2\n    - Sub-item\nor\n1. Item 1\n2. Item 2\nLinks:\n[OpenAI](https://www.openai.com/)\nImages:\n![Alt text](url)\nCode Blocks:\n```bash\n Code goes here\n```\nIn-line Code:\nUse `code` in your markdown file.\n\n\n\n\n\n\nThe beauty of Markdown lies in its simplicity. Stick to the basics unless there’s a strong reason to use a complex feature.\n\n\n\nIf you’re working on a longer document or a series of documents, be consistent in your style and formatting. This will make it easier for others (or future you) to read and modify the content.\n\n\n\nConsider using a Markdown style guide or linter to keep your formatting consistent. This is especially helpful for collaborative projects.\n\n\n\nMany platforms support Markdown extensions that provide additional features like tables, footnotes, and task lists. While these are useful, keep in mind that they may not be supported everywhere.\n\n\n\nAlways preview your Markdown file before publishing to make sure it looks the way you intended.\nBy adopting these best practices, you’ll be able to create content that is clean, easy to read, and easy to maintain."
  },
  {
    "objectID": "modules/00-markdown.html#why-is-markdown-useful",
    "href": "modules/00-markdown.html#why-is-markdown-useful",
    "title": "markdown",
    "section": "",
    "text": "Markdown is much simpler to learn compared to other markup languages like HTML. This makes it a quick tool for anyone who wants to write well-formatted content without the steep learning curve.\n\n\n\nMarkdown files are plain text files with a .md extension, which means they can be opened with any text editor. This makes them extremely portable and easy to manage.\n\n\n\nMarkdown is commonly used for readme files, GitHub repositories, blogging platforms like Jekyll, and even in data science notebooks like Jupyter.\n\n\n\nThe syntax is designed to be readable as-is, so even if you’re not rendering the Markdown to HTML or another format, it’s still easy to understand what’s going on."
  },
  {
    "objectID": "modules/00-markdown.html#markdown-syntax-and-examples",
    "href": "modules/00-markdown.html#markdown-syntax-and-examples",
    "title": "markdown",
    "section": "",
    "text": "Here are some basic examples of Markdown syntax:\n\nHeaders:\n# H1\n## H2\n### H3\nLists:\n- Item 1\n- Item 2\n    - Sub-item\nor\n1. Item 1\n2. Item 2\nLinks:\n[OpenAI](https://www.openai.com/)\nImages:\n![Alt text](url)\nCode Blocks:\n```bash\n Code goes here\n```\nIn-line Code:\nUse `code` in your markdown file."
  },
  {
    "objectID": "modules/00-markdown.html#best-practices",
    "href": "modules/00-markdown.html#best-practices",
    "title": "markdown",
    "section": "",
    "text": "The beauty of Markdown lies in its simplicity. Stick to the basics unless there’s a strong reason to use a complex feature.\n\n\n\nIf you’re working on a longer document or a series of documents, be consistent in your style and formatting. This will make it easier for others (or future you) to read and modify the content.\n\n\n\nConsider using a Markdown style guide or linter to keep your formatting consistent. This is especially helpful for collaborative projects.\n\n\n\nMany platforms support Markdown extensions that provide additional features like tables, footnotes, and task lists. While these are useful, keep in mind that they may not be supported everywhere.\n\n\n\nAlways preview your Markdown file before publishing to make sure it looks the way you intended.\nBy adopting these best practices, you’ll be able to create content that is clean, easy to read, and easy to maintain."
  },
  {
    "objectID": "modules/03-rstudio.html",
    "href": "modules/03-rstudio.html",
    "title": "RStudio",
    "section": "",
    "text": "RStudio is an Integrated Development Environment (IDE) for R, a programming language for statistical computing and data visualization. Developed by RStudio, Inc., this IDE provides a user-friendly interface to R, making it easier to write code, run analyses, and produce plots. It includes features such as syntax highlighting, code completion, and the ability to run R code interactively.\n\n\n\n\nRStudio consolidates your code, plots, and output in one place, improving workflow and making the process more efficient.\n\n\n\nWith features like auto-completion and built-in debugging tools, RStudio speeds up the coding process.\n\n\n\nRStudio simplifies the process of creating complex data visualizations by providing easy-to-use interfaces for ggplot2, Shiny, and other R packages.\n\n\n\nRStudio includes integrated support for Git and GitHub, making it easier to manage changes to your code and collaborate with others.\n\n\n\nRStudio supports various R packages and also allows the use of other programming languages like C++, Python, and SQL within the IDE.\n\n\n\n\n\nScript Editor: Write and edit your R scripts.\nConsole: Run R commands interactively.\n&gt; print(\"Hello, World!\")\nEnvironment: View and manage all variables, data frames, and other objects in your R session.\nPlots: Visualize your data and generate plots easily.\nggplot(data, aes(x=x, y=y)) + geom_point()\nPackages: Install and manage R packages.\ninstall.packages(\"tidyverse\")\nHelp: Access R documentation quickly.\nFile Browser: Navigate your file system and manage your project files.\nVersion Control: Manage Git repositories directly within RStudio.\ngit commit -m \"Initial commit\"\nShiny Apps: Build interactive web apps right within RStudio.\n\n\n\n\n\n\nUse RStudio Projects to keep your scripts, data, and other files organized. This makes it easier to manage complex analyses and collaborate with others.\n\n\n\nUse comments to describe what your code is doing. This makes it easier for you (and others) to understand the logic later.\n```R\n# Calculate the mean of x\nmean_x &lt;- mean(x)\n```\n\n\n\nMake your code and analyses reproducible. Use relative file paths and R Markdown documents to ensure others can easily run your code.\n\n\n\nUse Git to keep track of changes in your project. This is invaluable for collaboration and data science project management.\n\n\n\nDon’t reinvent the wheel. Make use of R’s extensive library of packages and functions to perform common tasks.\n\n\n\nLearn RStudio’s keyboard shortcuts to navigate the IDE more efficiently.\n\n\n\nTo make use of the latest features and improvements, keep your R and RStudio installations up to date.\nBy adhering to these best practices, you can make the most out of RStudio, whether you’re doing data analysis, statistical modeling, or creating data visualizations."
  },
  {
    "objectID": "modules/03-rstudio.html#why-is-rstudio-useful",
    "href": "modules/03-rstudio.html#why-is-rstudio-useful",
    "title": "RStudio",
    "section": "",
    "text": "RStudio consolidates your code, plots, and output in one place, improving workflow and making the process more efficient.\n\n\n\nWith features like auto-completion and built-in debugging tools, RStudio speeds up the coding process.\n\n\n\nRStudio simplifies the process of creating complex data visualizations by providing easy-to-use interfaces for ggplot2, Shiny, and other R packages.\n\n\n\nRStudio includes integrated support for Git and GitHub, making it easier to manage changes to your code and collaborate with others.\n\n\n\nRStudio supports various R packages and also allows the use of other programming languages like C++, Python, and SQL within the IDE."
  },
  {
    "objectID": "modules/03-rstudio.html#key-rstudio-features-and-examples",
    "href": "modules/03-rstudio.html#key-rstudio-features-and-examples",
    "title": "RStudio",
    "section": "",
    "text": "Script Editor: Write and edit your R scripts.\nConsole: Run R commands interactively.\n&gt; print(\"Hello, World!\")\nEnvironment: View and manage all variables, data frames, and other objects in your R session.\nPlots: Visualize your data and generate plots easily.\nggplot(data, aes(x=x, y=y)) + geom_point()\nPackages: Install and manage R packages.\ninstall.packages(\"tidyverse\")\nHelp: Access R documentation quickly.\nFile Browser: Navigate your file system and manage your project files.\nVersion Control: Manage Git repositories directly within RStudio.\ngit commit -m \"Initial commit\"\nShiny Apps: Build interactive web apps right within RStudio."
  },
  {
    "objectID": "modules/03-rstudio.html#best-practices",
    "href": "modules/03-rstudio.html#best-practices",
    "title": "RStudio",
    "section": "",
    "text": "Use RStudio Projects to keep your scripts, data, and other files organized. This makes it easier to manage complex analyses and collaborate with others.\n\n\n\nUse comments to describe what your code is doing. This makes it easier for you (and others) to understand the logic later.\n```R\n# Calculate the mean of x\nmean_x &lt;- mean(x)\n```\n\n\n\nMake your code and analyses reproducible. Use relative file paths and R Markdown documents to ensure others can easily run your code.\n\n\n\nUse Git to keep track of changes in your project. This is invaluable for collaboration and data science project management.\n\n\n\nDon’t reinvent the wheel. Make use of R’s extensive library of packages and functions to perform common tasks.\n\n\n\nLearn RStudio’s keyboard shortcuts to navigate the IDE more efficiently.\n\n\n\nTo make use of the latest features and improvements, keep your R and RStudio installations up to date.\nBy adhering to these best practices, you can make the most out of RStudio, whether you’re doing data analysis, statistical modeling, or creating data visualizations."
  },
  {
    "objectID": "modules/03-rstudio.html#r-markdown-and-report-generation",
    "href": "modules/03-rstudio.html#r-markdown-and-report-generation",
    "title": "RStudio",
    "section": "R Markdown and report generation",
    "text": "R Markdown and report generation\nTo effectively generate pretty reports you need to understand\n\nDocument structure: Learn the structure of an R Markdown document, which consists of a YAML header (metadata), code chunks, and narrative text.\nYAML header: Familiarize yourself with the YAML header and its key components such as ‘title’, ‘author’, ‘date’, and ‘output’. Customize the output format and options (e.g., ‘html_document’, ‘pdf_document’, or ‘word_document’).\nCode chunks: Understand how to insert and customize code chunks using triple backticks (```{r}), options like ‘echo’, ‘eval’, ‘include’, and ‘cache’, and inline R code using r.\nMarkdown syntax: Learn the basic Markdown syntax for formatting text, such as headers, lists, tables, links, images, and emphasis (bold, italics).\nKnitting: Get comfortable with the process of knitting an R Markdown document to generate the desired output format (e.g., HTML, PDF, or Word) using the “Knit” button in RStudio or the ‘rmarkdown::render()’ function.\nReproducible research: Learn the importance of reproducible research and best practices for organizing R projects, version control, and data management."
  },
  {
    "objectID": "modules/03-rstudio.html#code-chunks",
    "href": "modules/03-rstudio.html#code-chunks",
    "title": "RStudio",
    "section": "Code Chunks",
    "text": "Code Chunks\nCode chunk options are used to control the behavior and appearance of R code chunks in R Markdown documents. They are set within the curly braces {} following the language identifier (e.g., r). Here is a description of essential code chunk options to know and use:\n\necho: Determines whether the code chunk is displayed in the output document. Set echo=TRUE to display the code or echo=FALSE to hide it. The default is TRUE.\neval: Controls whether the code chunk is executed. Set eval=TRUE to execute the code or eval=FALSE to prevent execution. The default is TRUE.\ninclude: Determines whether the code chunk, its output, or both are included in the final output. Set include=TRUE to include both or include=FALSE to exclude both. The default is TRUE.\nresults: Controls the display of code chunk results. Options include 'markup' (default) to include the output as-is, 'hide' to hide the output, 'asis' to display raw results, and 'hold' to display all output at once at the end of the code chunk.\nmessage: Controls whether to display messages generated by the code chunk. Set message=TRUE to display messages or message=FALSE to hide them. The default is TRUE.\nwarning: Determines whether to display warnings generated by the code chunk. Set warning=TRUE to display warnings or warning=FALSE to hide them. The default is TRUE.\nerror: Controls whether to stop knitting if a code chunk generates an error. Set error=TRUE to continue knitting even if an error occurs or error=FALSE to stop knitting. The default is FALSE.\nfig.width and fig.height: Set the width and height of the output plots, respectively, in inches. For example, fig.width=6 and fig.height=4 set a 6x4-inch plot size.\nfig.align: Controls the horizontal alignment of plots in the output document. Options include 'left', 'center', and 'right'. The default is 'default', which depends on the output format.\ncache: Determines whether to cache the results of a code chunk. Set cache=TRUE to cache the results or cache=FALSE to re-run the code chunk every time the document is knit. The default is FALSE.\n\nBy understanding and using these essential code chunk options, you can gain better control over the execution, display, and formatting of your R code and its output within R Markdown documents.\n\ncache option\nThe cache option in R Markdown allows you to cache the results of code chunks, so they don’t need to be re-evaluated every time the document is knit. This can significantly speed up the knitting process for documents with computationally intensive or time-consuming code chunks.\nBenefits of using the cache option:\n\nFaster knitting: By caching the results of expensive code chunks, you can save time and resources when re-knitting your document, especially when only making small changes that don’t affect the cached chunks.\nConsistency: When working with random processes or time-sensitive data, caching the results can help maintain consistency across multiple versions of the document.\nResource management: Caching can help manage resources for large datasets or computationally intensive tasks that may otherwise cause the knitting process to fail or become unresponsive.\n\nHere’s an example of using the cache option in an R Markdown code chunk:\n```{r expensive-operation, cache=TRUE}\n# Simulate a time-consuming operation\nSys.sleep(10)\nresult &lt;- rnorm(1000, mean=100, sd=15)\nsummary(result)\n```\nIn this example, the code chunk simulates a time-consuming operation by waiting for 10 seconds before generating random data. By setting cache=TRUE, the results of this code chunk are cached, so that they are not re-evaluated every time the document is knit. This can save time and ensure that the random data remains consistent between document versions.\nKeep in mind that you should use the cache option carefully, as it may cause unexpected behavior if you’re caching results that depend on external resources or dynamic data. Always verify that your document produces the desired output when using the cache option."
  },
  {
    "objectID": "modules/03-rstudio.html#global-chunk-options",
    "href": "modules/03-rstudio.html#global-chunk-options",
    "title": "RStudio",
    "section": "Global Chunk Options",
    "text": "Global Chunk Options\nGlobal chunk options are settings that apply to all code chunks in an R Markdown document by default. You can set global options using the knitr::opts_chunk$set() function at the beginning of your R Markdown document, typically in an initial code chunk. By setting global options, you can maintain consistency across all code chunks and reduce the need to set options individually for each chunk.\nHere’s an example of setting global chunk options:\n```{r}\nlibrary(knitr)\nopts_chunk$set(\n  echo = TRUE,         # Display code chunks\n  eval = TRUE,         # Evaluate code chunks\n  warning = FALSE,     # Hide warnings\n  message = FALSE,     # Hide messages\n  fig.width = 6,       # Set plot width in inches\n  fig.height = 4,      # Set plot height in inches\n  fig.align = \"center\" # Align plots to the center\n)\n```"
  },
  {
    "objectID": "modules/03-rstudio.html#tables-and-images",
    "href": "modules/03-rstudio.html#tables-and-images",
    "title": "RStudio",
    "section": "Tables and Images",
    "text": "Tables and Images\nIn R Markdown, you can add tables and images using either Markdown syntax or R code.\n\nAdding tables:\n\nMarkdown syntax: You can create a simple table using pipes | and hyphens -. Here’s an example:\n\n| Column1 | Column2 | Column3 |\n|---------|---------|---------|\n| A       | B       | C       |\n| X       | Y       | Z       |\nThis will create a table with two rows and three columns.\n\nR code: You can create more complex tables using R packages like kable from the knitr package, or gt and flextable. Here’s an example using kable:\n\n```{r}\nlibrary(knitr)\n\ndata &lt;- data.frame(\n  Column1 = c(\"A\", \"X\"),\n  Column2 = c(\"B\", \"Y\"),\n  Column3 = c(\"C\", \"Z\")\n)\n\nkable(data, caption = \"An example table\")\n```\nThis will generate a table with the specified data and caption."
  },
  {
    "objectID": "modules/03-rstudio.html#adding-images",
    "href": "modules/03-rstudio.html#adding-images",
    "title": "RStudio",
    "section": "Adding images:",
    "text": "Adding images:\n\nMarkdown syntax: You can insert an image using the following syntax: ![alt text](path/to/image \"Optional title\"). Here’s an example:\n\n![Example image](path/to/image.jpg \"Optional title\")\nMake sure to replace path/to/image.jpg with the actual file path or URL of the image.\n\nR code: You can also add images using R code, especially if you’re generating images with R plots. Here’s two examples:\n\n```{r}\nplot(cars, main = \"An example plot\", xlab = \"Speed\", ylab = \"Distance\")\n```\n```{r schemat, echo = FALSE, out.width = “70%”, fig.align = “center”}\nknitr::include_graphics(“img/ncbi.png”)\n```\nThe benefit of the this code as opposed to Mardown (above) is that you the ability to change size and align"
  },
  {
    "objectID": "modules/03-rstudio.html#shiny-apps",
    "href": "modules/03-rstudio.html#shiny-apps",
    "title": "RStudio",
    "section": "Shiny Apps",
    "text": "Shiny Apps\nRStudio also provides a framework for building interactive web applications called Shiny apps. Shiny apps are built using R code and can be easily deployed on the web. They allow users to interact with data and visualizations in real-time, making it easy to explore and analyze complex data sets. Shiny apps are ideal for building dashboards, interactive reports, and other data-driven applications."
  },
  {
    "objectID": "modules/01-github.html",
    "href": "modules/01-github.html",
    "title": "GitHub",
    "section": "",
    "text": "GitHub is a web-based platform that provides hosting for software development and a set of tools for version control using Git. Created by Tom Preston-Werner, Chris Wanstrath, and PJ Hyett in 2008, GitHub has become one of the most popular platforms for developers to share code, collaborate on projects, and even showcase their portfolio.\n\n\n\n\nGitHub makes it extremely easy for multiple people to work on the same project. Features like forks, pull requests, and issues help facilitate effective collaboration.\n\n\n\nBuilt on Git, GitHub provides robust version control capabilities, allowing you to keep track of changes, revert to previous states, and work on different branches simultaneously.\n\n\n\nGitHub is not just for code. It’s widely used for documentation, thanks to support for Markdown and GitHub Pages which can turn repositories into full-fledged, static websites.\n\n\n\n\n\nRepositories: Central locations for storing all of your project’s files and revision history.\nCommits: Save changes to the repository.\ngit add .\ngit commit -m \"Your message here\"\nIssues: Report bugs, request features, and manage tasks in a project.\nActions: Automate tasks like building, testing, and deploying your code.\nGitHub Pages: Host websites directly from a GitHub repository.\n\n\n\n\n\n\nCommit messages should be concise and describe what was done and why. This makes it easier to review changes later.\n\n\n\nAlways include a README.md file to explain what your project is, how to set it up, and how to use it. Good documentation encourages collaboration.\n\n\n\nMake use of GitHub features like Projects, Milestones, and Labels to organize and track work on your repositories.\nBy adhering to these best practices, you can make the most out of GitHub’s myriad features for both personal and collaborative projects."
  },
  {
    "objectID": "modules/01-github.html#why-is-github-useful",
    "href": "modules/01-github.html#why-is-github-useful",
    "title": "GitHub",
    "section": "",
    "text": "GitHub makes it extremely easy for multiple people to work on the same project. Features like forks, pull requests, and issues help facilitate effective collaboration.\n\n\n\nBuilt on Git, GitHub provides robust version control capabilities, allowing you to keep track of changes, revert to previous states, and work on different branches simultaneously.\n\n\n\nGitHub is not just for code. It’s widely used for documentation, thanks to support for Markdown and GitHub Pages which can turn repositories into full-fledged, static websites."
  },
  {
    "objectID": "modules/01-github.html#key-github-features-and-examples",
    "href": "modules/01-github.html#key-github-features-and-examples",
    "title": "GitHub",
    "section": "",
    "text": "Repositories: Central locations for storing all of your project’s files and revision history.\nCommits: Save changes to the repository.\ngit add .\ngit commit -m \"Your message here\"\nIssues: Report bugs, request features, and manage tasks in a project.\nActions: Automate tasks like building, testing, and deploying your code.\nGitHub Pages: Host websites directly from a GitHub repository."
  },
  {
    "objectID": "modules/01-github.html#best-practices",
    "href": "modules/01-github.html#best-practices",
    "title": "GitHub",
    "section": "",
    "text": "Commit messages should be concise and describe what was done and why. This makes it easier to review changes later.\n\n\n\nAlways include a README.md file to explain what your project is, how to set it up, and how to use it. Good documentation encourages collaboration.\n\n\n\nMake use of GitHub features like Projects, Milestones, and Labels to organize and track work on your repositories.\nBy adhering to these best practices, you can make the most out of GitHub’s myriad features for both personal and collaborative projects."
  },
  {
    "objectID": "modules/02-bash.html",
    "href": "modules/02-bash.html",
    "title": "bash",
    "section": "",
    "text": "Bash, or the Bourne Again Shell, is a Unix shell and command-line interface for operating systems like Linux and macOS. Created by Brian Fox in 1989 as a free software replacement for the Bourne Shell, Bash is one of the most widely-used and powerful shells available. It serves as both a scripting language and an interactive command interpreter.\n\n\n\n\nBash scripts can automate repetitive tasks, making your workflow more efficient.\n\n\n\nBash is crucial for system administration tasks such as managing users, processes, and system updates.\n\n\n\nBash commands can be combined and executed in a variety of ways to perform complex tasks.\n\n\n\nBash scripts are usually portable across different Unix-based systems with little to no modification.\n\n\n\nBash can interact with other command-line tools and languages like awk, sed, and even Python, further extending its utility.\n\n\n\n\n\nCommands: The basic units of instruction in Bash.\nls  # List files\ncd directory/  # Change directory\nVariables: Store data that can be accessed and manipulated.\nNAME=\"John\"\necho $NAME\nControl Structures: If-else statements, loops, and case statements to control flow.\nif [ \"$a\" -eq \"$b\" ]; then\n    echo \"a is equal to b\"\nfi\nPipes and Redirection: Connect multiple commands and redirect output.\nls | grep '.txt'  # List only .txt files\necho \"Hello\" &gt; file.txt  # Write to file\nScripting: Combine all of the above to write complex scripts.\n#!/bin/bash\n# This is a simple script\necho \"Hello, world!\"\n\n\n\n\n\n\nAlways comment your scripts to explain what each part is doing. This is especially useful for more complex scripts.\n# This is a comment explaining the following line of code\nls\n\n\n\nChoose descriptive variable names to make your script more readable.\n# Good\nfile_count=10\n\n# Bad\nfc=10\n\n\n\nBash has many features, but that doesn’t mean you have to use them all. Stick to the simplest approach that gets the job done.\nBy following these best practices, you can write effective, robust, and maintainable Bash scripts, making the most of what this versatile tool has to offer."
  },
  {
    "objectID": "modules/02-bash.html#why-is-bash-useful",
    "href": "modules/02-bash.html#why-is-bash-useful",
    "title": "bash",
    "section": "",
    "text": "Bash scripts can automate repetitive tasks, making your workflow more efficient.\n\n\n\nBash is crucial for system administration tasks such as managing users, processes, and system updates.\n\n\n\nBash commands can be combined and executed in a variety of ways to perform complex tasks.\n\n\n\nBash scripts are usually portable across different Unix-based systems with little to no modification.\n\n\n\nBash can interact with other command-line tools and languages like awk, sed, and even Python, further extending its utility."
  },
  {
    "objectID": "modules/02-bash.html#key-bash-features-and-examples",
    "href": "modules/02-bash.html#key-bash-features-and-examples",
    "title": "bash",
    "section": "",
    "text": "Commands: The basic units of instruction in Bash.\nls  # List files\ncd directory/  # Change directory\nVariables: Store data that can be accessed and manipulated.\nNAME=\"John\"\necho $NAME\nControl Structures: If-else statements, loops, and case statements to control flow.\nif [ \"$a\" -eq \"$b\" ]; then\n    echo \"a is equal to b\"\nfi\nPipes and Redirection: Connect multiple commands and redirect output.\nls | grep '.txt'  # List only .txt files\necho \"Hello\" &gt; file.txt  # Write to file\nScripting: Combine all of the above to write complex scripts.\n#!/bin/bash\n# This is a simple script\necho \"Hello, world!\""
  },
  {
    "objectID": "modules/02-bash.html#best-practices",
    "href": "modules/02-bash.html#best-practices",
    "title": "bash",
    "section": "",
    "text": "Always comment your scripts to explain what each part is doing. This is especially useful for more complex scripts.\n# This is a comment explaining the following line of code\nls\n\n\n\nChoose descriptive variable names to make your script more readable.\n# Good\nfile_count=10\n\n# Bad\nfc=10\n\n\n\nBash has many features, but that doesn’t mean you have to use them all. Stick to the simplest approach that gets the job done.\nBy following these best practices, you can write effective, robust, and maintainable Bash scripts, making the most of what this versatile tool has to offer."
  },
  {
    "objectID": "modules/04-blast.html",
    "href": "modules/04-blast.html",
    "title": "NCBI Blast",
    "section": "",
    "text": "For the first task you will take an unknown multi-fasta file and annotate it using blast. You are welcome to do this in terminal, Rstudio, or jupyter. My recommendation, and how I will demonstrate is using Rmarkdown. Once you have have your project structured, we will download software, databases, a fasta file and run the code.\nThis is product offers a workflow to take a few thousand unidentified sequences and provide a better understanding of what genes are present. This will be accomplished through using Blast and protein sequenes from UniProt/Swiss-prot."
  },
  {
    "objectID": "modules/04-blast.html#obtain-fasta-uniprotswiss-prot",
    "href": "modules/04-blast.html#obtain-fasta-uniprotswiss-prot",
    "title": "NCBI Blast",
    "section": "Obtain Fasta (UniProt/Swiss-Prot)",
    "text": "Obtain Fasta (UniProt/Swiss-Prot)\nThis is from here picur reviewe sequences I named based on the identify of the database given\n\ncurrent_time &lt;- format(Sys.time(), \"%B %d, %Y %H:%M:%S\")\ncat(\"current date and time is \", current_time)\n\n\ncd ../data\ncurl -O https://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.fasta.gz\nmv uniprot_sprot.fasta.gz uniprot_sprot_r2023_04.fasta.gz\ngunzip -k uniprot_sprot_r2023_04.fasta.gz"
  },
  {
    "objectID": "modules/04-blast.html#making-the-database",
    "href": "modules/04-blast.html#making-the-database",
    "title": "NCBI Blast",
    "section": "Making the database",
    "text": "Making the database\n\nmkdir ../blastdb\n/home/shared/ncbi-blast-2.11.0+/bin/makeblastdb \\\n-in ../data/uniprot_sprot_r2023_01.fasta \\\n-dbtype prot \\\n-out ../blastdb/uniprot_sprot_r2023_01"
  },
  {
    "objectID": "modules/04-blast.html#prepping-blast-table-for-easy-join",
    "href": "modules/04-blast.html#prepping-blast-table-for-easy-join",
    "title": "NCBI Blast",
    "section": "Prepping Blast table for easy join",
    "text": "Prepping Blast table for easy join\n\ntr '|' '\\t' &lt; ../output/Ab_4-uniprot_blastx.tab \\\n&gt; ../output/Ab_4-uniprot_blastx_sep.tab\n\nhead -1 ../output/Ab_4-uniprot_blastx_sep.tab"
  },
  {
    "objectID": "modules/04-blast.html#could-do-some-cool-stuff-in-r-here-reading-in-table",
    "href": "modules/04-blast.html#could-do-some-cool-stuff-in-r-here-reading-in-table",
    "title": "NCBI Blast",
    "section": "Could do some cool stuff in R here reading in table",
    "text": "Could do some cool stuff in R here reading in table\n\nbltabl &lt;- read.csv(\"../output/Ab_4-uniprot_blastx_sep.tab\", sep = '\\t', header = FALSE)\n\nspgo &lt;- read.csv(\"https://gannet.fish.washington.edu/seashell/snaps/uniprot_table_r2023_01.tab\", sep = '\\t', header = TRUE)\n\n\ndatatable(head(bltabl), options = list(scrollX = TRUE, scrollY = \"400px\", scrollCollapse = TRUE, paging = FALSE))\n\n\ndatatable(head(spgo), options = list(scrollX = TRUE, scrollY = \"400px\", scrollCollapse = TRUE, paging = FALSE))\n\n\ndatatable(\n  left_join(bltabl, spgo,  by = c(\"V3\" = \"Entry\")) %&gt;%\n  select(V1, V3, V13, Protein.names, Organism, Gene.Ontology..biological.process., Gene.Ontology.IDs) %&gt;% mutate(V1 = str_replace_all(V1, \n            pattern = \"solid0078_20110412_FRAG_BC_WHITE_WHITE_F3_QV_SE_trimmed\", replacement = \"Ab\"))\n)\n\n\nannot_tab &lt;-\n  left_join(bltabl, spgo,  by = c(\"V3\" = \"Entry\")) %&gt;%\n  select(V1, V3, V13, Protein.names, Organism, Gene.Ontology..biological.process., Gene.Ontology.IDs) %&gt;% mutate(V1 = str_replace_all(V1, \n            pattern = \"solid0078_20110412_FRAG_BC_WHITE_WHITE_F3_QV_SE_trimmed\", replacement = \"Ab\"))\n\n\n# Read dataset\ndataset &lt;- read.csv(\"../output/blast_annot_go.tab\", sep = '\\t')  # Replace with the path to your dataset\n\n# Select the column of interest\ncolumn_name &lt;- \"Organism\"  # Replace with the name of the column of interest\ncolumn_data &lt;- dataset[[column_name]]\n\n# Count the occurrences of the strings in the column\nstring_counts &lt;- table(column_data)\n\n# Convert to a data frame, sort by count, and select the top 10\nstring_counts_df &lt;- as.data.frame(string_counts)\ncolnames(string_counts_df) &lt;- c(\"String\", \"Count\")\nstring_counts_df &lt;- string_counts_df[order(string_counts_df$Count, decreasing = TRUE), ]\ntop_10_strings &lt;- head(string_counts_df, n = 10)\n\n# Plot the top 10 most common strings using ggplot2\nggplot(top_10_strings, aes(x = reorder(String, -Count), y = Count, fill = String)) +\n  geom_bar(stat = \"identity\", position = \"dodge\", color = \"black\") +\n  labs(title = \"Top 10 Species hits\",\n       x = column_name,\n       y = \"Count\") +\n  theme_minimal() +\n  theme(legend.position = \"none\") +\n  coord_flip()\n\n\ndata &lt;- read.csv(\"../output/blast_annot_go.tab\", sep = '\\t')\n\n# Rename the `Gene.Ontology..biological.process.` column to `Biological_Process`\ncolnames(data)[colnames(data) == \"Gene.Ontology..biological.process.\"] &lt;- \"Biological_Process\"\n\n# Separate the `Biological_Process` column into individual biological processes\ndata_separated &lt;- unlist(strsplit(data$Biological_Process, split = \";\"))\n\n# Trim whitespace from the biological processes\ndata_separated &lt;- gsub(\"^\\\\s+|\\\\s+$\", \"\", data_separated)\n\n# Count the occurrences of each biological process\nprocess_counts &lt;- table(data_separated)\nprocess_counts &lt;- data.frame(Biological_Process = names(process_counts), Count = as.integer(process_counts))\nprocess_counts &lt;- process_counts[order(-process_counts$Count), ]\n\n# Select the 20 most predominant biological processes\ntop_20_processes &lt;- process_counts[1:20, ]\n\n# Create a color palette for the bars\nbar_colors &lt;- rainbow(nrow(top_20_processes))\n\n# Create a staggered vertical bar plot with different colors for each bar\nbarplot(top_20_processes$Count, names.arg = rep(\"\", nrow(top_20_processes)), col = bar_colors,\n        ylim = c(0, max(top_20_processes$Count) * 1.25),\n        main = \"Occurrences of the 20 Most Predominant Biological Processes\", xlab = \"Biological Process\", ylab = \"Count\")\n\n\n# Create a separate plot for the legend\npng(\"../output/GOlegend.png\", width = 800, height = 600)\npar(mar = c(0, 0, 0, 0))\nplot.new()\nlegend(\"center\", legend = top_20_processes$Biological_Process, fill = bar_colors, cex = 1, title = \"Biological Processes\")\ndev.off()\n\n\nknitr::include_graphics(\"../output/GOlegend.png\")"
  },
  {
    "objectID": "modules/04-blast.html#navigating-annotation",
    "href": "modules/04-blast.html#navigating-annotation",
    "title": "NCBI Blast",
    "section": "Navigating Annotation",
    "text": "Navigating Annotation\nThe following is a stepwise example or annotation of a gene set using UniProt::Swiss-Prot (reviewed) such that Gene Ontology terms can be associated with each gene.\nIn this following chunk where the fasta file is downloaded the release is noted and the file name is modified accordingly.\n\ncd DRAFT_Funct_Enrich/annot\n\ncurl -O https://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.fasta.gz\n\nmv uniprot_sprot.fasta.gz uniprot_sprot_r2023_02.fasta.gz\ngunzip -k uniprot_sprot_r2023_02.fasta.gz\n\nA protein blast database is then made.\n\n/home/shared/ncbi-blast-2.11.0+/bin/makeblastdb \\\n-in DRAFT_Funct_Enrich/annot/uniprot_sprot_r2023_02.fasta \\\n-dbtype prot \\\n-out DRAFT_Funct_Enrich/annot/uniprot_sprot_r2023_02\n\nIn a majority of cases you will want to annotate a gene set to get gene ontology information. If you are creating your own genome or transcriptome it should be rather straightforward to know what file to annotate. If using a widely studied system where there are publically available resources, it is advisable to use those as this is the best way to facilitate integration of data sets. In this case study we will be considering the Eastern oyster, (Crassostrea virginica) for which there is data at NCBI and Ensembl Metazoa. At NCBI there is both a GenBank and RefSeq assembly available.\nIn order to know which of the numerous fasta files should annotated with gene ontology information one should think downstream (or look to files already generated) to the identifiers in genesets that would be subject to functional enrichment tests.\nThe resulting fpkm count matrix for our case study is from an experiment where male and female oysters where exposed to low pH (and control) conditions. The count matrix is accessible here (csv). Hisat2/Stringtie was used to generate the count matrix with GCF_002022765.2_C_virginica-3.0_genomic.gff formatting thus responsible for gene naming. Specifically the naming format is as follows gene-LOC111099033,gene-LOC111099034,gene-LOC111099035.\nThe following fasta was selected for annotation: GCF_002022765.2_C_virginica-3.0_translated_cds.faa.gz\n\ncd DRAFT_Funct_Enrich/annot\n\ncurl -O https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/002/022/765/GCF_002022765.2_C_virginica-3.0/GCF_002022765.2_C_virginica-3.0_translated_cds.faa.gz\n\ngunzip -k GCF_002022765.2_C_virginica-3.0_translated_cds.faa.gz\n\n\nhead -2 DRAFT_Funct_Enrich/annot/GCF_002022765.2_C_virginica-3.0_translated_cds.faa\n\necho \"number of sequences\"\ngrep -c  \"&gt;\" DRAFT_Funct_Enrich/annot/GCF_002022765.2_C_virginica-3.0_translated_cds.faa\n\n&gt;lcl|NC_035780.1_prot_XP_022327646.1_1 [gene=LOC111126949] [db_xref=GeneID:111126949] [protein=UNC5C-like protein] [protein_id=XP_022327646.1] [location=join(30535..31557,31736..31887,31977..32565,32959..33204)] [gbkey=CDS]\nMTEVCYIWASSSTTVVICGIFFIVWRCFISIKKRASPLHGSSQQVCQTCQIEGHDFGEFQLSCRRQNTNVGYDLQGRRSD\nThis protein fasta is used as query for blast of uniprot_sprot database.\n\n/home/shared/ncbi-blast-2.11.0+/bin/blastp \\\n-query DRAFT_Funct_Enrich/annot/GCF_002022765.2_C_virginica-3.0_translated_cds.faa \\\n-db DRAFT_Funct_Enrich/annot/uniprot_sprot_r2023_02 \\\n-out DRAFT_Funct_Enrich/annot/Cvir_transcds-uniprot_blastp.tab \\\n-evalue 1E-20 \\\n-num_threads 40 \\\n-max_target_seqs 1 \\\n-outfmt 6\n\nHere is what the output file looks like, and at this point we want to get the UniProt Accession number for each gene\n\nhead -2 DRAFT_Funct_Enrich/annot/Cvir_transcds-uniprot_blastp.tab\n\n\nblast &lt;- read.csv(\"DRAFT_Funct_Enrich/annot/Cvir_transcds-uniprot_blastp.tab\", sep = '\\t', header = FALSE)\n\nConvert fasta to tab\n\nperl -e '$count=0; $len=0; while(&lt;&gt;) {s/\\r?\\n//; s/\\t/ /g; if (s/^&gt;//) { if ($. != 1) {print \"\\n\"} s/ |$/\\t/; $count++; $_ .= \"\\t\";} else {s/ //g; $len += length($_)} print $_;} print \"\\n\"; warn \"\\nConverted $count FASTA records in $. lines to tabular format\\nTotal sequence length: $len\\n\\n\";' \\\nDRAFT_Funct_Enrich/annot/GCF_002022765.2_C_virginica-3.0_translated_cds.faa &gt; DRAFT_Funct_Enrich/annot/GCF_002022765.2_C_virginica-3.0_translated_cds.tab\n\n\nhead -1 DRAFT_Funct_Enrich/annot/GCF_002022765.2_C_virginica-3.0_translated_cds.tab\n\n\ncdsftab &lt;- read.csv(\"DRAFT_Funct_Enrich/annot/GCF_002022765.2_C_virginica-3.0_translated_cds.tab\", sep = '\\t', header = FALSE, row.names=NULL)\n\nNow we can take the two data frames: A) blast output of taking protein fasta and comparing to uniprot_swiss-prot and B) a tabular version of same fasta file that has ID numbers of importance. Note this importance was determined based on what we want to use down stream.\n\ng.spid &lt;- left_join(blast, cdsftab, by = \"V1\") %&gt;%\n  mutate(gene = str_extract(V2.y, \"(?&lt;=\\\\[gene=)\\\\w+\")) %&gt;%\n  select(gene, V11, V2.x) %&gt;%\n  mutate(SPID = str_extract(V2.x, \"(?&lt;=\\\\|)[^\\\\|]*(?=\\\\|)\")) %&gt;%\n  distinct(gene, SPID, .keep_all = TRUE)\n\nLet’s break it down step by step:\n\ng.spid &lt;- left_join(blast, cdsftab, by = \"V1\") - This line is using the left_join() function from dplyr to merge the blast and cdsftab datasets by the column “V1”. A left join retains all the rows in the blast data frame and appends the matching rows in the cdsftab data frame. If there is no match, the result is NA. The result of this operation is assigned to the g.spid object.\nmutate(gene = str_extract(V2.y, \"(?&lt;=\\\\[gene=)\\\\w+\")) - This line is using the mutate() function from dplyr to add a new column called “gene” to the data frame. The new column is created by extracting substrings from the “V2.y” column based on the given regular expression pattern \"(?&lt;=\\\\[gene=)\\\\w+\". This regular expression matches and extracts any word (sequence of word characters, i.e., alphanumeric and underscore) that comes after “[gene=”.\nselect(gene, V11, V2.x) - This line is using the select() function from dplyr to keep only the specified columns (“gene”, “V11”, and “V2.x”) in the data frame.\nmutate(SPID = str_extract(V2.x, \"(?&lt;=\\\\|)[^\\\\|]*(?=\\\\|)\")) - Again, the mutate() function is used to add another new column named “SPID”. This column is created by extracting substrings from the “V2.x” column. The regular expression \"(?&lt;=\\\\|)[^\\\\|]*(?=\\\\|)\" is designed to extract any character(s) that is/are surrounded by “|” (pipe symbol). This is a common format for delimited strings.\ndistinct(gene, SPID, .keep_all = TRUE) - This line is using the distinct() function from dplyr to remove duplicate rows based on the “gene” and “SPID” columns. The .keep_all = TRUE argument means that all other columns are also kept in the result, not just the “gene” and “SPID” columns.\n\nThe resulting g.spid data frame should have unique rows with respect to the “gene” and “SPID” columns, and it should contain these two new columns, “gene” and “SPID”, extracted from the original data based on specific string patterns.\nNow lets just write out SPIDs.\n\nleft_join(blast, cdsftab, by = \"V1\") %&gt;%\n  mutate(gene = str_extract(V2.y, \"(?&lt;=\\\\[gene=)\\\\w+\")) %&gt;%\n  select(gene, V11, V2.x) %&gt;%\n  mutate(SPID = str_extract(V2.x, \"(?&lt;=\\\\|)[^\\\\|]*(?=\\\\|)\")) %&gt;%\n  distinct(gene, SPID, .keep_all = TRUE) %&gt;%\n  select(SPID) %&gt;%\n  write.table(file = \"DRAFT_Funct_Enrich/annot/SPID.txt\", sep = \"\\t\", row.names = FALSE, quote = FALSE\n ) \n\nWith a list of matching Swiss-Prot IDs, (technically UniProt Accession number) we can go back to https://www.uniprot.org and grab corresponding GO terms. This can be done via a web or using Python API.\nUsing Web\nUsing ID Mapping\n\n\n\nid\n\n\n\n\n\nfinished\n\n\nNow will customize columns to get GO IDs.\n\n\n\ncustcol\n\n\n\nhead -2 DRAFT_Funct_Enrich/annot/uniprotGO.tab\n\nFinally we can join table to get “LOCIDs” the notation for our DEGs, with GO terms.\n\ngo &lt;- read.csv(\"DRAFT_Funct_Enrich/annot/uniprotGO.tab\", sep = '\\t', header = TRUE, row.names=NULL)\n\n\nleft_join(g.spid, go, by = c(\"SPID\" = \"Entry\")) %&gt;%\n  select(gene,Gene.Ontology.IDs) %&gt;%\n  write.table(file = \"DRAFT_Funct_Enrich/annot/geneGO.txt\", sep = \"\\t\", row.names = FALSE, quote = FALSE\n  )\n\n\nhead DRAFT_Funct_Enrich/annot/geneGO.txt\n\nUsing API\n\npython3 DRAFT_Funct_Enrich/annot/uniprot-retrieval.py DRAFT_Funct_Enrich/annot/SPID.txt"
  }
]